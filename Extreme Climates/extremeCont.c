#include "../../cubiomes/biomenoise.h"
#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>
#include <time.h>

const uint64_t START_SEED = 0;
const uint64_t SEEDS_TO_CHECK = 10000000;
/* The sign of this indicates whether to look for minimum or maximum continentalnesses.
   The value of this specifies, between 0 and 1, what proportion of the maximum possible continentalness amplitude to use as a threshold.
   E.g. -0.2 will look for seeds with continentalnesses 20% that of the minimum.*/
const double CONT_THRESHOLD = -0.43;
//Set to 1 for Large Biomes generation, or 0 for normal generation.

const bool LARGE_BIOMES_FLAG = false;
const bool CHECK_PX_FLAG     = false;
const int NUMBER_OF_THREADS = 4;

const double MAX_PERLIN_VALUE = 1.0363538112118025;
const double DESIRED_CONT = (178./73 * MAX_PERLIN_VALUE) * CONT_THRESHOLD;
const int CONT_SIGN = CONT_THRESHOLD >= 0 ? 1 : -1;
const double Cdouble[] = {DESIRED_CONT - CONT_SIGN * (990./511 * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * (734./511 * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * (606./511 * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * (478./511 * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * ( 50./73  * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * (222./511 * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * (158./511 * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * ( 94./511 * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * ( 62./511 * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * ( 30./511 * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * ( 22./511 * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * (  2./73  * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * ( 10./511 * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * (  6./511 * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * (  4./511 * MAX_PERLIN_VALUE), DESIRED_CONT - CONT_SIGN * (  2./511 * MAX_PERLIN_VALUE),
						  DESIRED_CONT - CONT_SIGN * (  1./511 * MAX_PERLIN_VALUE), DESIRED_CONT};

typedef struct {
	uint64_t index;
	BiomeNoise bn;
} ThreadData;

// Copy of xPerlinInit without the amplitude/lacunarity resets (or pointless 256th iteration in second for loop)
void xReducedPerlinInit(PerlinNoise *noise, Xoroshiro *xr) {
    int i = 0;
    noise->a = xNextDouble(xr) * 256.;
    noise->b = xNextDouble(xr) * 256.;
    noise->c = xNextDouble(xr) * 256.;

    uint8_t *idx = noise->d;
    for (i = 0; i < 256; i++) idx[i] = i;
    for (i = 0; i < 255; i++) {
        int j = xNextInt(xr, 256 - i) + i;
        uint8_t n = idx[i];
        idx[i] = idx[j];
        idx[j] = n;
    }
    idx[256] = idx[0];
    double i2 = floor(noise->b);
    double d2 = noise->b - i2;
    noise->h2 = (int)i2;
    noise->d2 = d2;
    noise->t2 = d2*d2*d2 * (d2 * (d2*6. - 15.) + 10.);
}

void *checkSeed(void *dat) {
	ThreadData *data = dat;
	Xoroshiro pxr, pxr2;
	for (uint64_t count = data->index; count < SEEDS_TO_CHECK; count += NUMBER_OF_THREADS) {
		uint64_t seed = START_SEED + count;
		//Initializes first Xoroshiro generator with the seed, and saves the first two longs generated by it
		xSetSeed(&pxr, seed);
		uint64_t xloo = xNextLong(&pxr);
		uint64_t xhio = xNextLong(&pxr);

		double px = 0;
		uint64_t xlo2, xhi2;
		if (CHECK_PX_FLAG) {
			//Initializes depth octaves (34 - 39)
			pxr.lo = xloo ^ 0x080518cf6af25384;
			pxr.hi = xhio ^ 0x3f3dfb40a54febd5; // md5 "minecraft:offset"

			xlo2 = xNextLong(&pxr);
			xhi2 = xNextLong(&pxr);
			pxr2.lo = xlo2 ^ 0x53d39c6752dac858;
			pxr2.hi = xhi2 ^ 0xbcd1c5a80ab65b3e; // md5 "octave_-3"
			xReducedPerlinInit(&data->bn.oct[34], &pxr2);
			pxr2.lo = xlo2 ^ 0xb4a24d7a84e7677b;
			pxr2.hi = xhi2 ^ 0x023ff9668e89b5c4; // md5 "octave_-2"
			xReducedPerlinInit(&data->bn.oct[35], &pxr2);
			pxr2.lo = xlo2 ^ 0xdffa22b534c5f608;
			pxr2.hi = xhi2 ^ 0xb9b67517d3665ca9; // md5 "octave_-1"
			xReducedPerlinInit(&data->bn.oct[36], &pxr2);

			xlo2 = xNextLong(&pxr);
			xhi2 = xNextLong(&pxr);
			pxr2.lo = xlo2 ^ 0x53d39c6752dac858;
			pxr2.hi = xhi2 ^ 0xbcd1c5a80ab65b3e; // md5 "octave_-3"
			xReducedPerlinInit(&data->bn.oct[37], &pxr2);
			pxr2.lo = xlo2 ^ 0xb4a24d7a84e7677b;
			pxr2.hi = xhi2 ^ 0x023ff9668e89b5c4; // md5 "octave_-2"
			xReducedPerlinInit(&data->bn.oct[38], &pxr2);
			pxr2.lo = xlo2 ^ 0xdffa22b534c5f608;
			pxr2.hi = xhi2 ^ 0xb9b67517d3665ca9; // md5 "octave_-1"
			xReducedPerlinInit(&data->bn.oct[39], &pxr2);

			//Calculates px; for the case of (0, 0) pz = px, so we don't bother declaring pz until the next coordinate check
			px = 8./15 * (samplePerlin(&data->bn.oct[34], 0, 0, 0, 0, 0) + samplePerlin(&data->bn.oct[37], 0, 0, 0, 0, 0))
			   + 4./15 * (samplePerlin(&data->bn.oct[35], 0, 0, 0, 0, 0) + samplePerlin(&data->bn.oct[38], 0, 0, 0, 0, 0))
			   + 2./15 * (samplePerlin(&data->bn.oct[36], 0, 0, 0, 0, 0) + samplePerlin(&data->bn.oct[39], 0, 0, 0, 0, 0));
		}
		
		//Prepares first Xoroshiro for continental initialization, storing the first four longs into variables
		pxr.lo = xloo ^ (LARGE_BIOMES_FLAG ? 0x9a3f51a113fce8dc : 0x83886c9d0ae3a662);
		pxr.hi = xhio ^ (LARGE_BIOMES_FLAG ? 0xee2dbd157e5dcdad : 0xafa638a61b42e8ad); // md5 "minecraft:continentalness_large" or "minecraft:continentalness"
		uint64_t xlo = xNextLong(&pxr);
		uint64_t xhi = xNextLong(&pxr);
		xlo2 = xNextLong(&pxr);
		xhi2 = xNextLong(&pxr);

		/*Alternates between initiailizaing each octave in octA and octB of the continental octaves (8 - 25) and subsequently sampling them, because the octaves'
		decreasing amplitudes mean that each octave has less impact on the final climate sample value than the one before. After each sample, we then compare 
		npC to our previous lookup table, and discard the current seed if npC rises too high for an Nth-ring spawn to be possible. This way, we can continue on
		as quickly as possible and also while initializing as few octaves as possible.*/
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0x0fd787bfbc403ec3 : 0x082fe255f8be6631);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0x74a4a31ca21b48b8 : 0x4e96119e22dedc81); // md5 "octave_-11" or "octave_-9"
		xReducedPerlinInit(&data->bn.oct[8], &pxr2);
		double npC = 256./511 * samplePerlin(&data->bn.oct[8], px/(LARGE_BIOMES_FLAG ? 2048.0 : 512.0), 0, px/(LARGE_BIOMES_FLAG ? 2048.0 : 512.0), 0, 0);
		// data->bn.oct[8].a = xNextDouble(&pxr2) * 256.0;
		// data->bn.oct[8].b = xNextDouble(&pxr2) * 256.0;
		// double zeroPx = px/(LARGE_BIOMES_FLAG ? 2048.0 : 512.0);
		// double d1 = zeroPx + data->bn.oct[8].a;
		// double d1 = px/(LARGE_BIOMES_FLAG ? 2048.0 : 512.0) + data->bn.oct[8].a;
		// int i1 = (int)d1 - (int)(d1 < 0);
		// int i2 = (int)(data->bn.oct[8].b);
		// d1 -= i1;
		// double d2 = data->bn.oct[8].b - i2;
		// double x = Cdouble[0]*511/256.0;
		// double x1 = x + 1;
		// double x2 = x + 2;
		// if (x <= -d1 - d2 && x1 <= d1 - d2 && x1 <= d2 - d1 && x2 <= d1 + d2) continue;

		// data->bn.oct[8].c = xNextDouble(&pxr2) * 256.0;
		// // double d3 = zeroPx + data->bn.oct[8].c;
		// double d3 = px/(LARGE_BIOMES_FLAG ? 2048.0 : 512.0) + data->bn.oct[8].c;
		// int i3 = (int)d3 - (int)(d3 < 0);
		// d3 -= i3;
		// if (x <= -d1 - d3 && x <= -d2 - d3
		// 	&& x1 <= d1 - d3 && x1 <= d3 - d1 && x1 <= d2 - d3 && x1 <= d3 - d2
		// 	&& x2 <= d1 + d3 && x2 <= d2 + d3) continue;

		// i1 &= 0xff;
		// i2 &= 0xff;
		// i3 &= 0xff;

		// for (int i = 0; i < 256; ++i) data->bn.oct[8].d[i] = i;
		// for (int i = 0; i < 255; ++i) {
		// 	int j = xNextInt(&pxr2, 256 - i) + i;
		// 	uint8_t n = data->bn.oct[8].d[i];
		// 	data->bn.oct[8].d[i] = data->bn.oct[8].d[j];
		// 	data->bn.oct[8].d[j] = n;
		// 	data->bn.oct[8].d[i + 256] = data->bn.oct[8].d[i];
		// }
		// data->bn.oct[8].d[511] = data->bn.oct[8].d[255];
		// int a1 = data->bn.oct[8].d[i1]     + i2;
		// int a2 = data->bn.oct[8].d[a1]     + i3;
		// // if ((data->bn.oct[8].d[a2] % 4 != 3) || (data->bn.oct[8].d[a2 + 1] % 14 != 3 && data->bn.oct[8].d[a2 + 1] % 14 != 5 && data->bn.oct[8].d[a2 + 1] % 14 != 9 && data->bn.oct[8].d[a2 + 1] % 14 != 13)) continue;
		// int a3 = data->bn.oct[8].d[a1 + 1] + i3;
		// // if ((data->bn.oct[8].d[a3] % 13 != 1 && data->bn.oct[8].d[a3] % 13 != 7 && data->bn.oct[8].d[a3] % 13 != 10) || (data->bn.oct[8].d[a3 + 1] % 13 != 1 && data->bn.oct[8].d[a3 + 1] % 13 != 5 && data->bn.oct[8].d[a3 + 1] % 13 != 8)) continue;
		// int b1 = data->bn.oct[8].d[i1 + 1] + i2;
		// int b2 = data->bn.oct[8].d[b1]     + i3;
		// // if ((data->bn.oct[8].d[b2] % 9 != 2 && data->bn.oct[8].d[b2] % 9 != 6) || (data->bn.oct[8].d[b2 + 1] % 15 != 2 && data->bn.oct[8].d[b2 + 1] % 15 != 4 && data->bn.oct[8].d[b2 + 1] % 15 != 9 && data->bn.oct[8].d[b2 + 1] % 15 != 13)) continue;
		// int b3 = data->bn.oct[8].d[b1 + 1] + i3;
		// // if ((data->bn.oct[8].d[b3] % 12 != 0 && data->bn.oct[8].d[b3] % 12 != 6 && data->bn.oct[8].d[b3] % 12 != 10) || (data->bn.oct[8].d[b2 + 1] % 4 != 0)) continue;

		// double l1 = indexedLerp(data->bn.oct[8].d[a2],   d1,   d2,   d3);
		// double l2 = indexedLerp(data->bn.oct[8].d[b2],   d1-1, d2,   d3);
		// double l3 = indexedLerp(data->bn.oct[8].d[a3],   d1,   d2-1, d3);
		// double l4 = indexedLerp(data->bn.oct[8].d[b3],   d1-1, d2-1, d3);
		// double l5 = indexedLerp(data->bn.oct[8].d[a2+1], d1,   d2,   d3-1);
		// double l6 = indexedLerp(data->bn.oct[8].d[b2+1], d1-1, d2,   d3-1);
		// double l7 = indexedLerp(data->bn.oct[8].d[a3+1], d1,   d2-1, d3-1);
		// double l8 = indexedLerp(data->bn.oct[8].d[b3+1], d1-1, d2-1, d3-1);
		// if (x <= l1 && x <= l2 && x <= l3 && x <= l4 && x <= l5 && x <= l6 && x <= l7 && x <= l8) continue;

		// double t1 = d1*d1*d1 * (d1 * (d1*6.0 - 15.0) + 10.0);

		// l1 = lerp(t1, l1, l2);
		// l3 = lerp(t1, l3, l4);
		// l5 = lerp(t1, l5, l6);
		// l7 = lerp(t1, l7, l8);
		// if (x <= l1 && x <= l3 && x <= l5 && x <= l7) continue;

		// double t2 = d2*d2*d2 * (d2 * (d2*6.0 - 15.0) + 10.0);
		// l1 = lerp(t2, l1, l3);
		// l5 = lerp(t2, l5, l7);
		// if (x <= l1 && x <= l5) continue;

		// double t3 = d3*d3*d3 * (d3 * (d3*6.0 - 15.0) + 10.0);
		// double npC = 256/511.0 * lerp(t3, l1, l5);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[0] > npC : Cdouble[0] < npC) continue;
		if (CONT_SIGN * Cdouble[0] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0x0fd787bfbc403ec3 : 0x082fe255f8be6631);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0x74a4a31ca21b48b8 : 0x4e96119e22dedc81); // md5 "octave_-11" or "octave_-9"
		xReducedPerlinInit(&data->bn.oct[17], &pxr2);
		npC += 256./511 * samplePerlin(&data->bn.oct[17], px * (LARGE_BIOMES_FLAG ? 337./677888 : 337./169472), 0, px * (LARGE_BIOMES_FLAG ? 337./677888 : 337./169472), 0, 0);
		// zeroPx = px * (LARGE_BIOMES_FLAG ? 337/677888.0 : 337/169472.0);
		// npC += 256/511.0 * samplePerlin(&data->bn.oct[17], zeroPx, 0, zeroPx, 0, 0);
		// d1 = px * (LARGE_BIOMES_FLAG ? 337/677888.0 : 337/169472.0) + data->bn.oct[17].a;
		// i1 = (int)d1 - (int)(d1 < 0);
		// i2 = (int)(data->bn.oct[17].b);
		// d1 -= i1;
		// d2 = data->bn.oct[17].b - i2;
		// x = (Cdouble[1] - npC)*511/256.0;
		// x1 = x + 1;
		// x2 = x + 2;
		// if (x <= -d1 - d2 && x1 <= d1 - d2 && x1 <= d2 - d1 && x2 <= d1 + d2) continue;

		// data->bn.oct[17].c = xNextDouble(&pxr2) * 256.0;
		// // double d3 = zeroPx + data->bn.oct[17].c;
		// d3 = px * (LARGE_BIOMES_FLAG ? 337/677888.0 : 337/169472.0) + data->bn.oct[17].c;
		// i3 = (int)d3 - (int)(d3 < 0);
		// d3 -= i3;
		// if (x <= -d1 - d3 && x <= -d2 - d3
		// && x1 <= d1 - d3 && x1 <= d3 - d1 && x1 <= d2 - d3 && x1 <= d3 - d2
		// && x2 <= d1 + d3 && x2 <= d2 + d3) continue;

		// i1 &= 0xff;
		// i2 &= 0xff;
		// i3 &= 0xff;

		// for (int i = 0; i < 256; ++i) data->bn.oct[17].d[i] = i;
		// for (int i = 0; i < 255; ++i) {
		// 	int j = xNextInt(&pxr2, 256 - i) + i;
		// 	uint8_t n = data->bn.oct[17].d[i];
		// 	data->bn.oct[17].d[i] = data->bn.oct[17].d[j];
		// 	data->bn.oct[17].d[j] = n;
		// 	data->bn.oct[17].d[i + 256] = data->bn.oct[17].d[i];
		// }
		// data->bn.oct[17].d[511] = data->bn.oct[17].d[255];
		// a1 = data->bn.oct[17].d[i1]     + i2;
		// a2 = data->bn.oct[17].d[a1]     + i3;
		// // if ((data->bn.oct[17].d[a2] % 4 != 3) || (data->bn.oct[17].d[a2 + 1] % 14 != 3 && data->bn.oct[17].d[a2 + 1] % 14 != 5 && data->bn.oct[17].d[a2 + 1] % 14 != 9 && data->bn.oct[17].d[a2 + 1] % 14 != 13)) continue;
		// a3 = data->bn.oct[17].d[a1 + 1] + i3;
		// // if ((data->bn.oct[17].d[a3] % 13 != 1 && data->bn.oct[17].d[a3] % 13 != 7 && data->bn.oct[17].d[a3] % 13 != 10) || (data->bn.oct[17].d[a3 + 1] % 13 != 1 && data->bn.oct[17].d[a3 + 1] % 13 != 5 && data->bn.oct[17].d[a3 + 1] % 13 != 8)) continue;
		// b1 = data->bn.oct[17].d[i1 + 1] + i2;
		// b2 = data->bn.oct[17].d[b1]     + i3;
		// // if ((data->bn.oct[17].d[b2] % 9 != 2 && data->bn.oct[17].d[b2] % 9 != 6) || (data->bn.oct[17].d[b2 + 1] % 15 != 2 && data->bn.oct[17].d[b2 + 1] % 15 != 4 && data->bn.oct[17].d[b2 + 1] % 15 != 9 && data->bn.oct[17].d[b2 + 1] % 15 != 13)) continue;
		// b3 = data->bn.oct[17].d[b1 + 1] + i3;
		// // if ((data->bn.oct[17].d[b3] % 12 != 0 && data->bn.oct[17].d[b3] % 12 != 6 && data->bn.oct[17].d[b3] % 12 != 10) || (data->bn.oct[17].d[b2 + 1] % 4 != 0)) continue;

		// l1 = indexedLerp(data->bn.oct[17].d[a2],   d1,   d2,   d3);
		// l2 = indexedLerp(data->bn.oct[17].d[b2],   d1-1, d2,   d3);
		// l3 = indexedLerp(data->bn.oct[17].d[a3],   d1,   d2-1, d3);
		// l4 = indexedLerp(data->bn.oct[17].d[b3],   d1-1, d2-1, d3);
		// l5 = indexedLerp(data->bn.oct[17].d[a2+1], d1,   d2,   d3-1);
		// l6 = indexedLerp(data->bn.oct[17].d[b2+1], d1-1, d2,   d3-1);
		// l7 = indexedLerp(data->bn.oct[17].d[a3+1], d1,   d2-1, d3-1);
		// l8 = indexedLerp(data->bn.oct[17].d[b3+1], d1-1, d2-1, d3-1);
		// if (x <= l1 && x <= l2 && x <= l3 && x <= l4 && x <= l5 && x <= l6 && x <= l7 && x <= l8) continue;

		// t1 = d1*d1*d1 * (d1 * (d1*6.0 - 15.0) + 10.0);

		// l1 = lerp(t1, l1, l2);
		// l3 = lerp(t1, l3, l4);
		// l5 = lerp(t1, l5, l6);
		// l7 = lerp(t1, l7, l8);
		// if (x <= l1 && x <= l3 && x <= l5 && x <= l7) continue;

		// t2 = d2*d2*d2 * (d2 * (d2*6.0 - 15.0) + 10.0);
		// l1 = lerp(t2, l1, l3);
		// l5 = lerp(t2, l5, l7);
		// if (x <= l1 && x <= l5) continue;

		// t3 = d3*d3*d3 * (d3 * (d3*6.0 - 15.0) + 10.0);
		// npC += 256/511.0 * lerp(t3, l1, l5);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[1] > npC : Cdouble[1] < npC) continue;
		if (CONT_SIGN * Cdouble[1] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0x36d326eed40efeb2 : 0x0ef68ec68504005e);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0x5be9ce18223c636a : 0x48b6bf93a2789640); // md5 "octave_-10" or "octave_-8"
		xReducedPerlinInit(&data->bn.oct[9], &pxr2);
		npC += 128./511 * samplePerlin(&data->bn.oct[9], px/(LARGE_BIOMES_FLAG ? 1024.0 : 256.0), 0, px/(LARGE_BIOMES_FLAG ? 1024.0 : 256.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[2] > npC : Cdouble[2] < npC) continue;
		if (CONT_SIGN * Cdouble[2] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0x36d326eed40efeb2 : 0x0ef68ec68504005e);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0x5be9ce18223c636a : 0x48b6bf93a2789640); // md5 "octave_-10" or "octave_-8"
		xReducedPerlinInit(&data->bn.oct[18], &pxr2);
		npC += 128./511 * samplePerlin(&data->bn.oct[18], px * (LARGE_BIOMES_FLAG ? 337/338944.0 : 337/84736.0), 0, px * (LARGE_BIOMES_FLAG ? 337/338944.0 : 337/84736.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[3] > npC : Cdouble[3] < npC) continue;
		if (CONT_SIGN * Cdouble[3] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0x082fe255f8be6631 : 0xf11268128982754f);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0x4e96119e22dedc81 : 0x257a1d670430b0aa); // md5 "octave_-9" or "octave_-7"
		xReducedPerlinInit(&data->bn.oct[10], &pxr2);
		npC += 128./511 * samplePerlin(&data->bn.oct[10], px/(LARGE_BIOMES_FLAG ? 512.0 : 128.0), 0, px/(LARGE_BIOMES_FLAG ? 512.0 : 128.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[4] > npC : Cdouble[4] < npC) continue;
		if (CONT_SIGN * Cdouble[4] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0x082fe255f8be6631 : 0xf11268128982754f);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0x4e96119e22dedc81 : 0x257a1d670430b0aa); // md5 "octave_-9" or "octave_-7"
		xReducedPerlinInit(&data->bn.oct[19], &pxr2);
		npC += 128./511 * samplePerlin(&data->bn.oct[19], px * (LARGE_BIOMES_FLAG ? 337/169472.0 : 337/42368.0), 0, px * (LARGE_BIOMES_FLAG ? 337/169472.0 : 337/42368.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[5] > npC : Cdouble[5] < npC) continue;
		if (CONT_SIGN * Cdouble[5] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0x0ef68ec68504005e : 0xe51c98ce7d1de664);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0x48b6bf93a2789640 : 0x5f9478a733040c45); // md5 "octave_-8" or "octave_-6"
		xReducedPerlinInit(&data->bn.oct[11], &pxr2);
		npC += 64./511 * samplePerlin(&data->bn.oct[11], px/(LARGE_BIOMES_FLAG ? 256.0 : 64.0), 0, px/(LARGE_BIOMES_FLAG ? 256.0 : 64.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[6] > npC : Cdouble[6] < npC) continue;
		if (CONT_SIGN * Cdouble[6] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0x0ef68ec68504005e : 0xe51c98ce7d1de664);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0x48b6bf93a2789640 : 0x5f9478a733040c45); // md5 "octave_-8" or "octave_-6"
		xReducedPerlinInit(&data->bn.oct[20], &pxr2);
		npC += 64/511.0 * samplePerlin(&data->bn.oct[20], px * (LARGE_BIOMES_FLAG ? 337/84736.0 : 337/21184.0), 0, px * (LARGE_BIOMES_FLAG ? 337/84736.0 : 337/21184.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[7] > npC : Cdouble[7] < npC) continue;
		if (CONT_SIGN * Cdouble[7] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0xf11268128982754f : 0x6d7b49e7e429850a);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0x257a1d670430b0aa : 0x2e3063c622a24777); // md5 "octave_-7" or "octave_-5"
		xReducedPerlinInit(&data->bn.oct[12], &pxr2);
		npC += 32/511.0 * samplePerlin(&data->bn.oct[12], px/(LARGE_BIOMES_FLAG ? 128.0 : 32.0), 0, px/(LARGE_BIOMES_FLAG ? 128.0 : 32.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[8] > npC : Cdouble[8] < npC) continue;
		if (CONT_SIGN * Cdouble[8] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0xf11268128982754f : 0x6d7b49e7e429850a);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0x257a1d670430b0aa : 0x2e3063c622a24777); // md5 "octave_-7" or "octave_-5"
		xReducedPerlinInit(&data->bn.oct[21], &pxr2);
		npC += 32/511.0 * samplePerlin(&data->bn.oct[21], px * (LARGE_BIOMES_FLAG ? 337/42368.0 : 337/10592.0), 0, px * (LARGE_BIOMES_FLAG ? 337/42368.0 : 337/10592.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[9] > npC : Cdouble[9] < npC) continue;
		if (CONT_SIGN * Cdouble[9] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0xe51c98ce7d1de664 : 0xbd90d5377ba1b762);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0x5f9478a733040c45 : 0xc07317d419a7548d); // md5 "octave_-6" or "octave_-4"
		xReducedPerlinInit(&data->bn.oct[13], &pxr2);
		npC += 8/511.0 * samplePerlin(&data->bn.oct[13], px/(LARGE_BIOMES_FLAG ? 64.0 : 16.0), 0, px/(LARGE_BIOMES_FLAG ? 64.0 : 16.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[10] > npC : Cdouble[10] < npC) continue;
		if (CONT_SIGN * Cdouble[10] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0xe51c98ce7d1de664 : 0xbd90d5377ba1b762);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0x5f9478a733040c45 : 0xc07317d419a7548d); // md5 "octave_-6" or "octave_-4"
		xReducedPerlinInit(&data->bn.oct[22], &pxr2);
		npC += 8/511.0 * samplePerlin(&data->bn.oct[22], px * (LARGE_BIOMES_FLAG ? 337/21184.0 : 337/5296.0), 0, px * (LARGE_BIOMES_FLAG ? 337/21184.0 : 337/5296.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[11] > npC : Cdouble[11] < npC) continue;
		if (CONT_SIGN * Cdouble[11] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0x6d7b49e7e429850a : 0x53d39c6752dac858);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0x2e3063c622a24777 : 0xbcd1c5a80ab65b3e); // md5 "octave_-5" or "octave_-3"
		xReducedPerlinInit(&data->bn.oct[14], &pxr2);
		npC += 4/511.0 * samplePerlin(&data->bn.oct[14], px/(LARGE_BIOMES_FLAG ? 32.0 : 8.0), 0, px/(LARGE_BIOMES_FLAG ? 32.0 : 8.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[12] > npC : Cdouble[12] < npC) continue;
		if (CONT_SIGN * Cdouble[12] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0x6d7b49e7e429850a : 0x53d39c6752dac858);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0x2e3063c622a24777 : 0xbcd1c5a80ab65b3e); // md5 "octave_-5" or "octave_-3"
		xReducedPerlinInit(&data->bn.oct[23], &pxr2);
		npC += 4/511.0 * samplePerlin(&data->bn.oct[23], px * (LARGE_BIOMES_FLAG ? 337/10592.0 : 337/2648.0), 0, px * (LARGE_BIOMES_FLAG ? 337/10592.0 : 337/2648.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[13] > npC : Cdouble[13] < npC) continue;
		if (CONT_SIGN * Cdouble[13] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0xbd90d5377ba1b762 : 0xb4a24d7a84e7677b);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0xc07317d419a7548d : 0x023ff9668e89b5c4); // md5 "octave_-4" or "octave_-2"
		xReducedPerlinInit(&data->bn.oct[15], &pxr2);
		npC += 2/511.0 * samplePerlin(&data->bn.oct[15], px/(LARGE_BIOMES_FLAG ? 16.0 : 4.0), 0, px/(LARGE_BIOMES_FLAG ? 16.0 : 4.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[14] > npC : Cdouble[14] < npC) continue;
		if (CONT_SIGN * Cdouble[14] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0xbd90d5377ba1b762 : 0xb4a24d7a84e7677b);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0xc07317d419a7548d : 0x023ff9668e89b5c4); // md5 "octave_-4" or "octave_-2"
		xReducedPerlinInit(&data->bn.oct[24], &pxr2);
		npC += 2/511.0 * samplePerlin(&data->bn.oct[24], px * (LARGE_BIOMES_FLAG ? 337/5296.0 : 337/1324.0), 0, px * (LARGE_BIOMES_FLAG ? 337/5296.0 : 337/1324.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[15] > npC : Cdouble[15] < npC) continue;
		if (CONT_SIGN * Cdouble[15] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo ^ (LARGE_BIOMES_FLAG ? 0x53d39c6752dac858 : 0xdffa22b534c5f608);
		pxr2.hi = xhi ^ (LARGE_BIOMES_FLAG ? 0xbcd1c5a80ab65b3e : 0xb9b67517d3665ca9); // md5 "octave_-3" or "octave_-1"
		xReducedPerlinInit(&data->bn.oct[16], &pxr2);
		npC += 1/511.0 * samplePerlin(&data->bn.oct[16], px/(LARGE_BIOMES_FLAG ? 8.0 : 2.0), 0, px/(LARGE_BIOMES_FLAG ? 8.0 : 2.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[16] > npC : Cdouble[16] < npC) continue;
		if (CONT_SIGN * Cdouble[16] > CONT_SIGN * npC) continue;
		pxr2.lo = xlo2 ^ (LARGE_BIOMES_FLAG ? 0x53d39c6752dac858 : 0xdffa22b534c5f608);
		pxr2.hi = xhi2 ^ (LARGE_BIOMES_FLAG ? 0xbcd1c5a80ab65b3e : 0xb9b67517d3665ca9); // md5 "octave_-3" or "octave_-1"
		xReducedPerlinInit(&data->bn.oct[25], &pxr2);
		npC += 1/511.0 * samplePerlin(&data->bn.oct[25], px * (LARGE_BIOMES_FLAG ? 337/2648.0 : 337/662.0), 0, px * (LARGE_BIOMES_FLAG ? 337/2648.0 : 337/662.0), 0, 0);
		// if (CONT_THRESHOLD >= 0 ? Cdouble[17] > npC : Cdouble[17] < npC) continue;
		if (CONT_SIGN * Cdouble[17] > CONT_SIGN * npC) continue;
		/*Prints the seed.*/
		printf("%" PRId64 "\n", seed);
		// if (npC <= -2.4) printf("(<= -2.4)\n");
	}
	return NULL;
}

int main() {
	pthread_t threads[NUMBER_OF_THREADS];
	ThreadData data[NUMBER_OF_THREADS];
	for (int i = 0; i < NUMBER_OF_THREADS; ++i) {
		/*Manually sets all constant attributes of the biome noise. In the raw cubiomes functions, these values are derived anew each time,
		  but given that the same values generate each time we can simply use a lookup table instead of forcing them to be generated over time.*/
		data[i].bn.climate[NP_CONTINENTALNESS].amplitude    = 3./2;
		data[i].bn.climate[NP_CONTINENTALNESS].octA.octaves = &(data[i].bn.oct[8]);
		data[i].bn.climate[NP_CONTINENTALNESS].octB.octaves = &(data[i].bn.oct[17]);
		data[i].bn.climate[NP_CONTINENTALNESS].octA.octcnt  = data[i].bn.climate[NP_CONTINENTALNESS].octB.octcnt = 9;
		data[i].bn.oct[8].amplitude   = 256./511;
		data[i].bn.oct[8].lacunarity  = 1./(LARGE_BIOMES_FLAG ? 2048 : 512);
		data[i].bn.oct[9].amplitude   = data[i].bn.oct[10].amplitude = 128./511;
		data[i].bn.oct[9].lacunarity  = 1./(LARGE_BIOMES_FLAG ? 1024 : 256);
		data[i].bn.oct[10].lacunarity = 1./(LARGE_BIOMES_FLAG ? 512 : 128);
		data[i].bn.oct[11].amplitude  = 64./511;
		data[i].bn.oct[11].lacunarity = 1./(LARGE_BIOMES_FLAG ? 256 : 64);
		data[i].bn.oct[12].amplitude  = 32./511;
		data[i].bn.oct[12].lacunarity = 1./(LARGE_BIOMES_FLAG ? 128 : 32);
		data[i].bn.oct[13].amplitude  = 8./511;
		data[i].bn.oct[13].lacunarity = 1./(LARGE_BIOMES_FLAG ? 64 : 16);
		data[i].bn.oct[14].amplitude  = 4./511;
		data[i].bn.oct[14].lacunarity = 1./(LARGE_BIOMES_FLAG ? 32 : 8);
		data[i].bn.oct[15].amplitude  = 2./511;
		data[i].bn.oct[15].lacunarity = 1./(LARGE_BIOMES_FLAG ? 16 : 4);
		data[i].bn.oct[16].amplitude  = 1./511;
		data[i].bn.oct[16].lacunarity = 1./(LARGE_BIOMES_FLAG ? 8 : 2);
		data[i].bn.oct[17].amplitude  = data[i].bn.oct[8].amplitude;
		data[i].bn.oct[17].lacunarity = data[i].bn.oct[8].lacunarity;
		data[i].bn.oct[18].amplitude  = data[i].bn.oct[9].amplitude;
		data[i].bn.oct[18].lacunarity = data[i].bn.oct[9].lacunarity;
		data[i].bn.oct[19].amplitude  = data[i].bn.oct[10].amplitude;
		data[i].bn.oct[19].lacunarity = data[i].bn.oct[10].lacunarity;
		data[i].bn.oct[20].amplitude  = data[i].bn.oct[11].amplitude;
		data[i].bn.oct[20].lacunarity = data[i].bn.oct[11].lacunarity;
		data[i].bn.oct[21].amplitude  = data[i].bn.oct[12].amplitude;
		data[i].bn.oct[21].lacunarity = data[i].bn.oct[12].lacunarity;
		data[i].bn.oct[22].amplitude  = data[i].bn.oct[13].amplitude;
		data[i].bn.oct[22].lacunarity = data[i].bn.oct[13].lacunarity;
		data[i].bn.oct[23].amplitude  = data[i].bn.oct[14].amplitude;
		data[i].bn.oct[23].lacunarity = data[i].bn.oct[14].lacunarity;
		data[i].bn.oct[24].amplitude  = data[i].bn.oct[15].amplitude;
		data[i].bn.oct[24].lacunarity = data[i].bn.oct[15].lacunarity;
		data[i].bn.oct[25].amplitude  = data[i].bn.oct[16].amplitude;
		data[i].bn.oct[25].lacunarity = data[i].bn.oct[16].lacunarity;
		if (CHECK_PX_FLAG) {
			data[i].bn.climate[NP_SHIFT].amplitude    = 5./4;
			data[i].bn.climate[NP_SHIFT].octA.octaves = &(data[i].bn.oct[34]);
			data[i].bn.climate[NP_SHIFT].octB.octaves = &(data[i].bn.oct[37]);
			data[i].bn.climate[NP_SHIFT].octA.octcnt  = data[i].bn.climate[NP_SHIFT].octB.octcnt = 3;
			data[i].bn.oct[34].amplitude  = data[i].bn.oct[37].amplitude  = 8./15;
			data[i].bn.oct[34].lacunarity = data[i].bn.oct[37].lacunarity = 1./8;
			data[i].bn.oct[35].amplitude  = data[i].bn.oct[38].amplitude  = 4./15;
			data[i].bn.oct[35].lacunarity = data[i].bn.oct[38].lacunarity = 1./4;
			data[i].bn.oct[36].amplitude  = data[i].bn.oct[39].amplitude  = 2./15;
			data[i].bn.oct[36].lacunarity = data[i].bn.oct[39].lacunarity = 1./2;
		}
	}
	struct timespec startTime, endTime;
	clock_gettime(CLOCK_MONOTONIC, &startTime);
	//Iterates over N seeds, beginning at the one originally specified by the user
	for (int i = 0; i < NUMBER_OF_THREADS; ++i) {
		data[i].index = i;
		pthread_create(&threads[i], NULL, checkSeed, &data[i]);
	}
	for (int i = 0; i < NUMBER_OF_THREADS; ++i) pthread_join(threads[i], NULL);
	clock_gettime(CLOCK_MONOTONIC, &endTime);
	printf("(%f seconds)\n", endTime.tv_sec - startTime.tv_sec + (endTime.tv_nsec - startTime.tv_nsec)/1.e9);
	return 0;
}